name: On PR create/ready metadata update via Codex

on:
  pull_request:
    types: [opened, ready_for_review]

permissions:
  pull-requests: write
  contents: read

concurrency:
  group: metadata-codex-pr-${{ github.event.pull_request.number }}
  cancel-in-progress: false

jobs:
  request_codex:
    if: >
      (github.event.action == 'opened' && github.event.pull_request.draft == false) ||
      (github.event.action == 'ready_for_review')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR head
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Load trusted allowlist (base SHA)
        id: trusted_inputs
        shell: bash
        run: |
          set -euo pipefail
          BASE_REF="${{ github.event.pull_request.base.ref }}"
          BASE_SHA="${{ github.event.pull_request.base.sha }}"

          # Ensure BASE_SHA is present locally (fetch-by-ref is more robust than fetch-by-sha).
          git fetch --no-tags origin "$BASE_REF"

          allowlist_file="$(mktemp)"
          git show "${BASE_SHA}:.github/metadata/allowlist.txt" > "$allowlist_file"

          echo "allowlist_file=$allowlist_file" >> "$GITHUB_OUTPUT"

      - name: Compute allowlisted A/M/D targets
        id: targets
        shell: bash
        run: |
          set -euo pipefail
          ALLOWLIST_FILE="${{ steps.trusted_inputs.outputs.allowlist_file }}" python - << 'PY' >> "$GITHUB_OUTPUT"
          import fnmatch, os, pathlib, subprocess

          base = "${{ github.event.pull_request.base.sha }}"
          head = "${{ github.event.pull_request.head.sha }}"

          def git(*args):
              return subprocess.check_output(["git", *args], text=True).splitlines()

          # allowlist parsing
          allow_path = pathlib.Path(os.environ["ALLOWLIST_FILE"])
          lines=[]
          if allow_path.exists():
              for raw in allow_path.read_text(encoding="utf-8").splitlines():
                  s=raw.strip()
                  if not s or s.startswith("#"):
                      continue
                  lines.append(s)
          includes=[x for x in lines if not x.startswith("!")]
          excludes=[x[1:] for x in lines if x.startswith("!")]

          def allowed(p:str)->bool:
              if not p.endswith(".rs"): return False
              if includes and not any(fnmatch.fnmatch(p, pat) for pat in includes): return False
              if excludes and any(fnmatch.fnmatch(p, pat) for pat in excludes): return False
              return True

          rows = git("diff","--name-status", base, head)

          added=[]; modified=[]; deleted=[]
          for r in rows:
              parts=r.split("\t")
              st=parts[0]
              if st.startswith(("R","C")) and len(parts) >= 3:
                  old,new = parts[1], parts[2]
                  if allowed(old): deleted.append(old)
                  if allowed(new): added.append(new)
                  continue
              if len(parts) < 2:
                  continue
              path=parts[1]
              if not allowed(path):
                  continue
              if st=="A": added.append(path)
              elif st=="M": modified.append(path)
              elif st=="D": deleted.append(path)

          def fmt(xs):
              xs=sorted(set(xs))
              return "\n".join(f"- {x}" for x in xs) if xs else "(none)"

          print("added<<EOF"); print(fmt(added)); print("EOF")
          print("modified<<EOF"); print(fmt(modified)); print("EOF")
          print("deleted<<EOF"); print(fmt(deleted)); print("EOF")
          PY

      - name: Post @codex job comment (dedup by marker)
        uses: actions/github-script@v7
        env:
          ADDED: ${{ steps.targets.outputs.added }}
          MODIFIED: ${{ steps.targets.outputs.modified }}
          DELETED: ${{ steps.targets.outputs.deleted }}
        with:
          github-token: ${{ secrets.AUTHOR_TOKEN }}
          script: |
            const pr = context.payload.pull_request.number;
            const marker = "METADATA_JOB_REQUEST_V1";
            const recordedSha = context.payload.pull_request.head.sha;
            const baseSha = context.payload.pull_request.base.sha;

            const added = (process.env.ADDED || "").trimEnd();
            const modified = (process.env.MODIFIED || "").trimEnd();
            const deleted = (process.env.DELETED || "").trimEnd();

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr,
              per_page: 100
            });

            const trustedAssociations = new Set(["OWNER", "MEMBER", "COLLABORATOR", "BOT"]);
            const alreadyPosted = comments.some(c => {
              const body = c.body || "";
              if (!body.includes(marker)) {
                return false;
              }
              const assoc = c.author_association || "";
              const isBot = c.user && c.user.type === "Bot";
              return isBot || trustedAssociations.has(assoc);
            });

            if (alreadyPosted) {
              core.info("Codex metadata request already posted; skipping.");
              return;
            }

            const body = [
              "@codex",
              "",
              marker,
              `METADATA_ON_CREATE_SHA:${recordedSha}`,
              `METADATA_BASE_SHA:${baseSha}`,
              "",
              "Please update Rust metadata files for this PR. Submit the result directly to GitHub (commit) without asking for toggles or confirmations.",
              "",
              "Rules:",
              "- Allowlist: use `.github/metadata/allowlist.txt` at METADATA_BASE_SHA (ignore PR edits).",
              "- Prompt: follow `.github/metadata/prompt.txt` at METADATA_BASE_SHA exactly (ignore PR edits).",
              "- Output path mapping: `/path/to/src/a.rs` -> `/path/to/src/a.metadata.txt`",
              "- Added Rust file: generate metadata from Rust source + prompt.",
              "- Modified Rust file: update metadata using Rust source + existing metadata + prompt.",
              "- Deleted Rust file: if corresponding .metadata.txt exists, delete it.",
              "- Skip Rust files < 100 lines; include list of skipped files in summary.",
              "",
              "Targets:",
              "Added:",
              added,
              "",
              "Modified:",
              modified,
              "",
              "Deleted:",
              deleted,
            ].join("\n") + "\n";

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr,
              body
            });
