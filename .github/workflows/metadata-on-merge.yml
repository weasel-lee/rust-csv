name: On PR approval metadata update via Codex

on:
  pull_request_review:
    types: [submitted]

permissions:
  pull-requests: write
  contents: read

concurrency:
  group: metadata-codex-approval-${{ github.event.pull_request.number }}
  cancel-in-progress: false

jobs:
  request_codex_on_approval:
    if: >
      github.event.review.state == 'approved' &&
      github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR head
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: Read latest metadata request record
        id: record_sha
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const markers = new Set(["METADATA_JOB_REQUEST_V1", "METADATA_APPROVAL_JOB_V1"]);
            const shaPatterns = [
              /METADATA_ON_CREATE_SHA:([0-9a-f]{40})/,
              /METADATA_ON_APPROVAL_SHA:([0-9a-f]{40})/
            ];
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100
            });

            let recorded = "";
            const trustedAssociations = new Set(["OWNER", "MEMBER", "COLLABORATOR", "BOT"]);
            for (const comment of [...comments].reverse()) {
              const body = comment.body || "";
              if (![...markers].some(marker => body.includes(marker))) {
                continue;
              }
              const assoc = comment.author_association || "";
              const isBot = comment.user && comment.user.type === "Bot";
              if (!isBot && !trustedAssociations.has(assoc)) {
                continue;
              }
              for (const pattern of shaPatterns) {
                const match = body.match(pattern);
                if (match) {
                  recorded = match[1];
                  break;
                }
              }
              if (recorded) {
                break;
              }
            }
            core.setOutput("recorded_sha", recorded);

      - name: Compute allowlisted A/M/D targets since last metadata update
        id: targets
        shell: bash
        run: |
          set -euo pipefail
          RECORDED_SHA="${{ steps.record_sha.outputs.recorded_sha }}"
          PR_BASE="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          if [[ -n "$RECORDED_SHA" ]]; then
            git fetch --no-tags origin "$RECORDED_SHA" "$HEAD_SHA"
            if git merge-base --is-ancestor "$RECORDED_SHA" "$HEAD_SHA"; then
              DIFF_BASE="$RECORDED_SHA"
            else
              echo "Recorded SHA is not in PR history; using base SHA."
              DIFF_BASE="$PR_BASE"
              git fetch --no-tags origin "$PR_BASE"
            fi
          else
            DIFF_BASE="$PR_BASE"
            git fetch --no-tags origin "$PR_BASE"
          fi

          DIFF_BASE="$DIFF_BASE" HEAD_SHA="$HEAD_SHA" python - << 'PY' >> "$GITHUB_OUTPUT"
          import fnmatch
          import os
          import pathlib
          import subprocess

          base_sha = os.environ["DIFF_BASE"]
          head_sha = os.environ["HEAD_SHA"]

          def git(*args):
              return subprocess.check_output(["git", *args], text=True).splitlines()

          allow_path = pathlib.Path(".github/metadata/allowlist.txt")
          lines = []
          if allow_path.exists():
              for raw in allow_path.read_text(encoding="utf-8").splitlines():
                  s = raw.strip()
                  if not s or s.startswith("#"):
                      continue
                  lines.append(s)
          includes = [x for x in lines if not x.startswith("!")]
          excludes = [x[1:] for x in lines if x.startswith("!")]

          def allowed(p: str) -> bool:
              if not p.endswith(".rs"):
                  return False
              if includes and not any(fnmatch.fnmatch(p, pat) for pat in includes):
                  return False
              if excludes and any(fnmatch.fnmatch(p, pat) for pat in excludes):
                  return False
              return True

          changed = git("diff", "--name-only", base_sha, head_sha)
          rs_changes = [p for p in changed if allowed(p)]
          meta_changes = [p for p in changed if p.endswith(".metadata.txt")]
          skip = "true" if (not rs_changes or meta_changes) else "false"

          rows = git("diff", "--name-status", base_sha, head_sha)
          added = []
          modified = []
          deleted = []
          for r in rows:
              parts = r.split("\t")
              st = parts[0]
              if st.startswith(("R", "C")) and len(parts) >= 3:
                  old, new = parts[1], parts[2]
                  if allowed(old):
                      deleted.append(old)
                  if allowed(new):
                      added.append(new)
                  continue
              if len(parts) < 2:
                  continue
              path = parts[1]
              if not allowed(path):
                  continue
              if st == "A":
                  added.append(path)
              elif st == "M":
                  modified.append(path)
              elif st == "D":
                  deleted.append(path)

          def fmt(xs):
              xs = sorted(set(xs))
              return "\n".join(f"- {x}" for x in xs) if xs else "(none)"

          print(f"skip={skip}")
          print("added<<EOF")
          print(fmt(added))
          print("EOF")
          print("modified<<EOF")
          print(fmt(modified))
          print("EOF")
          print("deleted<<EOF")
          print(fmt(deleted))
          print("EOF")
          PY

      - name: Skip metadata update (already handled or no relevant changes)
        if: steps.targets.outputs.skip == 'true'
        shell: bash
        run: |
          echo "Skip metadata update (no allowlisted Rust changes or metadata already updated)."

      - name: Post @codex job comment
        if: steps.targets.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTHOR_TOKEN }}
          script: |
            const pr = context.payload.pull_request.number;
            const marker = "METADATA_APPROVAL_JOB_V1";
            const recordedSha = context.payload.pull_request.head.sha;

            const body = `@codex

            ${marker}
            METADATA_ON_APPROVAL_SHA:${recordedSha}

            Please update Rust metadata files for this PR. Submit the result directly to GitHub (commit) without asking for toggles or confirmations.

            Rules:
            - Allowlist: use glob patterns from \`.github/metadata/allowlist.txt\` (supports !exclude lines).
            - Output path mapping: \`/path/to/src/a.rs\` -> \`/path/to/src/a.metadata.txt\`
            - Prompt: follow \`.github/metadata/prompt.txt\` exactly for output structure and style.
            - Added Rust file: generate metadata from Rust source + prompt.
            - Modified Rust file: update metadata using Rust source + existing metadata + prompt.
            - Deleted Rust file: if corresponding .metadata.txt exists, delete it.
            - Skip Rust files < 100 lines; include list of skipped files in summary.

            Targets (since last metadata update):
            Added:
            ${{ steps.targets.outputs.added }}

            Modified:
            ${{ steps.targets.outputs.modified }}

            Deleted:
            ${{ steps.targets.outputs.deleted }}
            `;
                        await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: pr,
                          body
                        });
