# Flow summary:
# Create unique branch, push empty commit, open PR.
# Calculate allowlisted A/M/D targets from the merged diff.
# Post @codex job comment in the new PR.

# I think the hash logic is necessary to avoid opening unnecessary PRs when there's no significant change since the on-create commit.
name: Metadata via Codex post-merge (opens PR)

on:
  pull_request:
    # This should be 'merged'. PR which is not merged will be ignored.
    types: [closed]

permissions:
  contents: write
  pull-requests: write

jobs:
  post_merge:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      - name: Checkout default branch
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Read metadata-on-create record
        id: record_sha
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const marker = "METADATA_ON_CREATE_SHA:";
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100
            });

            let recorded = "";
            for (const comment of comments) {
              const body = comment.body || "";
              const match = body.match(/METADATA_ON_CREATE_SHA:([0-9a-f]{40})/);
              if (match) {
                recorded = match[1];
              }
            }
            core.setOutput("recorded_sha", recorded);

      - name: Check for post-merge metadata update requirement
        id: skip_check
        shell: bash
        run: |
          set -euo pipefail
          RECORDED_SHA="${{ steps.record_sha.outputs.recorded_sha }}"
          MERGE_SHA="${{ github.event.pull_request.merge_commit_sha }}"

          if [[ -n "$RECORDED_SHA" ]]; then
            git fetch --no-tags origin "$RECORDED_SHA" "$MERGE_SHA"
            BASE_SHA="$RECORDED_SHA"
            HEAD_SHA="$MERGE_SHA"
          else
            PR_HEAD="${{ github.event.pull_request.head.sha }}"
            git fetch --no-tags origin "$PR_HEAD" "$MERGE_SHA"

            METADATA_COMMIT="$(git log -n 1 --pretty=%H "$PR_HEAD" -- '**/*.metadata.txt' || true)"
            if [[ -z "$METADATA_COMMIT" ]]; then
              echo "skip=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            BASE_SHA="$METADATA_COMMIT"
            HEAD_SHA="$MERGE_SHA"
          fi

          BASE_SHA="$BASE_SHA" HEAD_SHA="$HEAD_SHA" python - << 'PY' >> "$GITHUB_OUTPUT"
          import fnmatch
          import os
          import pathlib
          import subprocess

          base_sha = os.environ["BASE_SHA"]
          head_sha = os.environ["HEAD_SHA"]

          def git(*args):
              return subprocess.check_output(["git", *args], text=True).splitlines()

          allow_path = pathlib.Path(".github/metadata/allowlist.txt")
          lines = []
          if allow_path.exists():
              for raw in allow_path.read_text(encoding="utf-8").splitlines():
                  s = raw.strip()
                  if not s or s.startswith("#"):
                      continue
                  lines.append(s)
          includes = [x for x in lines if not x.startswith("!")]
          excludes = [x[1:] for x in lines if x.startswith("!")]

          def allowed(p: str) -> bool:
              if not p.endswith(".rs"):
                  return False
              if includes and not any(fnmatch.fnmatch(p, pat) for pat in includes):
                  return False
              if excludes and any(fnmatch.fnmatch(p, pat) for pat in excludes):
                  return False
              return True

          changed = git("diff", "--name-only", base_sha, head_sha)
          rs_changes = [p for p in changed if allowed(p)]
          skip = "true" if not rs_changes else "false"
          print(f"skip={skip}")
          PY

      - name: Skip post-merge metadata update (no new code changes)
        if: steps.skip_check.outputs.skip == 'true'
        shell: bash
        run: |
          echo "No additional allowlisted Rust changes since metadata update; skipping post-merge metadata workflow."

      # Create branch only when there's change(except metadata update) since the on-create commit.
      # For example, if we know the metadata-update commit from the on-create action, we can skip this step if there's no additional commit or code change from the on-create commit.
      - name: Create unique branch
        id: branch
        if: steps.skip_check.outputs.skip != 'true'
        shell: bash
        run: |
          set -euo pipefail
          TS="$(date -u +'%Y%m%d-%H%M%S')"
          BR="bot/metadata-post-merge-pr${{ github.event.pull_request.number }}-$TS"
          echo "name=$BR" >> "$GITHUB_OUTPUT"
          git checkout -b "$BR"

      # If branch hasn't been created, this step isn't necessary neither.
      - name: Push empty commit (so PR can be opened)
        if: steps.skip_check.outputs.skip != 'true'
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git commit --allow-empty -m "chore: post-merge metadata scaffold"
          git push origin HEAD

      - name: Open PR
        id: openpr
        if: steps.skip_check.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const base = context.payload.pull_request.base.ref;
            const head = "${{ steps.branch.outputs.name }}";
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Post-merge metadata update (after #${context.payload.pull_request.number})`,
              head,
              base,
              body: `Auto-update *.metadata.txt after PR #${context.payload.pull_request.number} merged.`
            });
            core.setOutput("pr_number", pr.number);

      - name: Compute allowlisted A/M/D targets for the merge
        id: targets
        if: steps.skip_check.outputs.skip != 'true'
        shell: bash
        run: |
          set -euo pipefail
          MERGE_SHA="${{ github.event.pull_request.merge_commit_sha }}"
          git fetch --no-tags origin "$MERGE_SHA"
          git checkout "$MERGE_SHA"
          BASE_SHA="$(git rev-parse "$MERGE_SHA^")"

          python - << 'PY' >> "$GITHUB_OUTPUT"
          import fnmatch, pathlib, subprocess

          merge = "${{ github.event.pull_request.merge_commit_sha }}"
          base = subprocess.check_output(["git","rev-parse",f"{merge}^"], text=True).strip()

          def git(*args):
              return subprocess.check_output(["git", *args], text=True).splitlines()

          allow_path = pathlib.Path(".github/metadata/allowlist.txt")
          lines=[]
          if allow_path.exists():
              for raw in allow_path.read_text(encoding="utf-8").splitlines():
                  s=raw.strip()
                  if not s or s.startswith("#"): 
                      continue
                  lines.append(s)
          includes=[x for x in lines if not x.startswith("!")]
          excludes=[x[1:] for x in lines if x.startswith("!")]

          def allowed(p:str)->bool:
              if not p.endswith(".rs"): return False
              if includes and not any(fnmatch.fnmatch(p, pat) for pat in includes): return False
              if excludes and any(fnmatch.fnmatch(p, pat) for pat in excludes): return False
              return True

          rows = git("diff","--name-status", base, merge)

          added=[]; modified=[]; deleted=[]
          for r in rows:
              parts=r.split("\t")
              st=parts[0]
              if st.startswith(("R","C")) and len(parts) >= 3:
                  old,new = parts[1], parts[2]
                  if allowed(old): deleted.append(old)
                  if allowed(new): added.append(new)
                  continue
              if len(parts) < 2: 
                  continue
              path=parts[1]
              if not allowed(path): 
                  continue
              if st=="A": added.append(path)
              elif st=="M": modified.append(path)
              elif st=="D": deleted.append(path)

          def fmt(xs):
              xs=sorted(set(xs))
              return "\n".join(f"- {x}" for x in xs) if xs else "(none)"

          print("added<<EOF"); print(fmt(added)); print("EOF")
          print("modified<<EOF"); print(fmt(modified)); print("EOF")
          print("deleted<<EOF"); print(fmt(deleted)); print("EOF")
          PY

      - name: Post @codex job comment in the new PR
        if: steps.skip_check.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTHOR_TOKEN }}
          script: |
            const prNum = Number("${{ steps.openpr.outputs.pr_number }}");
            const marker = "METADATA_POST_MERGE_JOB_V1";

            const body = `@codex

            ${marker}

            Please update Rust metadata files in this PR (post-merge fixup). Submit the result directly to GitHub (commit) without asking for toggles or confirmations.

            Rules:
            - Allowlist: \`.github/metadata/allowlist.txt\` (supports !exclude).
            - Output path mapping: \`/path/to/src/a.rs\` -> \`/path/to/src/a.metadata.txt\`
            - Prompt: follow \`.github/metadata/prompt.txt\` exactly.
            - Added Rust file: create metadata from Rust source + prompt.
            - Modified Rust file: update metadata using Rust source + existing metadata + prompt.
            - Deleted Rust file: delete corresponding .metadata.txt if exists.
            - Do not include housekeeping hash headers like "# source_sha256:" in your output.

            Targets (from merged diff):
            Added:
            ${{ steps.targets.outputs.added }}

            Modified:
            ${{ steps.targets.outputs.modified }}

            Deleted:
            ${{ steps.targets.outputs.deleted }}
            `;
                        await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: prNum,
                          body
                        });
